generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum MessageRole {
  user
  assistant
}

enum RunMode {
  AUTO
  COMPARE
  CHAIN
}

enum RunStatus {
  PENDING
  RUNNING
  DONE
  ERROR
}

enum StepType {
  ROUTER
  MODEL_CALL
  JUDGE
  MERGE
  COMPRESS
  CRITIQUE
  DRAFT
  REFINE
}

enum StepStatus {
  PENDING
  RUNNING
  DONE
  ERROR
}

enum Provider {
  openai
  anthropic
  google
  mistral
  mock
}

enum ArtifactKind {
  FINAL_ANSWER
  CODE
  MEMO
  JSON
}

enum MemoryItemType {
  FACT
  PREFERENCE
  DECISION
  ARTIFACT_REF
}

model Session {
  id          String       @id @default(cuid())
  title       String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  messages    Message[]
  runs        Run[]
  artifacts   Artifact[]
  memoryItems MemoryItem[]

  @@index([updatedAt])
}

model Message {
  id         String      @id @default(cuid())
  sessionId  String
  role       MessageRole
  content    String      @db.Text
  createdAt  DateTime    @default(now())
  session    Session     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  triggerRun Run?        @relation("UserMessageRun")

  @@index([sessionId, createdAt])
}

model Run {
  id                String    @id @default(cuid())
  sessionId         String
  mode              RunMode
  userMessageId     String?
  selectedModelIds  String[]  @default([])
  preferencesJson   Json?
  cpirJson          Json
  contextPackJson   Json
  routerDecisionJson Json?
  status            RunStatus @default(PENDING)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  totalInputTokens  Int       @default(0)
  totalOutputTokens Int       @default(0)
  totalCostUsd      Float     @default(0)
  totalLatencyMs    Int       @default(0)

  session     Session   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  userMessage Message?  @relation("UserMessageRun", fields: [userMessageId], references: [id], onDelete: SetNull)
  steps       Step[]
  artifacts   Artifact[]

  @@index([sessionId, createdAt])
  @@index([status])
}

model Step {
  id             String     @id @default(cuid())
  runId          String
  type           StepType
  provider       Provider
  modelId        String
  renderedPrompt String     @default("") @db.Text
  outputRaw      String     @default("") @db.Text
  outputParsedJson Json?
  status         StepStatus @default(PENDING)
  startedAt      DateTime?
  finishedAt     DateTime?
  inputTokens    Int        @default(0)
  outputTokens   Int        @default(0)
  costUsd        Float      @default(0)
  latencyMs      Int        @default(0)
  errorMessage   String?    @db.Text
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  run Run @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId, createdAt])
  @@index([type])
  @@index([status])
}

model Artifact {
  id        String       @id @default(cuid())
  sessionId String
  runId     String?
  kind      ArtifactKind
  title     String
  content   String       @db.Text
  createdAt DateTime     @default(now())

  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  run     Run?    @relation(fields: [runId], references: [id], onDelete: SetNull)

  @@index([sessionId, createdAt])
  @@index([runId])
}

model MemoryItem {
  id          String         @id @default(cuid())
  sessionId   String
  type        MemoryItemType
  key         String
  value       Json
  confidence  Float          @default(0.5)
  enabled     Boolean        @default(true)
  sourceRunId String?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sourceRun Run?  @relation(fields: [sourceRunId], references: [id], onDelete: SetNull)

  @@index([sessionId, enabled])
  @@index([sourceRunId])
  @@unique([sessionId, key])
}
